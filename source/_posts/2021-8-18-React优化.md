---
title: 2021-8-18-React优化
date: 2021-08-18 17:30:36
tags: React
---
# React优化实践

## 1. 受控组件优化

可控性组件和非可控性的区别就是dom元素值是否与受到react数据状态state控制。一旦由react的state控制数据状态，比如input输入框的值，就会造成这样一个场景，为了使input值实时变化，会不断setState，就会不断触发render函数。例如：
```typescript
const Index:React.FC<PropsType> = (props) => {
    const [num, setNum] = useState(1);
    return (
    <div>
        <input type="number" value={num} onChange={(e) => setNum(e.target.value)} />
        <ComponentA>
        <ComponentB>
        /** 数组生成组件  */
    </div>
  )
}
```
这种情况下如果子组件有`componentWillReceiveProps`这种副作用的钩子将会引起蝴蝶效应，同时也会重新遍历数组生成组件。
## 2. `React.memo`、`shouldComponentUpdate`和`immetable.js`控制组件更新
`React.memo`(`shouldComponentUpdate`在类组件作用与其类似)是一个高阶组件可以包装组件控制其更新，其第二个参数的函数中两个参数为上次传入组件的`props`和当前的`props`，可以进行手动比较如果返回`false`则更新,如不传第二个参数则进行`props`浅比较，例如：
```typescript
export default React.memo(TextLoop, (prevProps, nextProps) => prevProps.show === nextProps.show) ;
```
Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。在React中使用可以使只有数据变化的地方更新。
## 3. 组件Props传参
`props`改变会进行一次渲染，如果父组件向子组件传递`props`使用了以下写法会导致每次子组件都会渲染。
```typescript
<div onClick={() => console.log('render')} />
<ComponentA config={{type:'a', value:1}} />
```
正确的做法是使用`useMemo`缓存这些箭头函数或对象：
```typescript
const [handleClick, config] = useMemo(()=>{
    return[() => console.log('render'), {type:'a', value:1}]
},[])
// ...代码
<div onClick={handleClick} />
<ComponentA config={config} />
```
## 4. 从循环中生成组件时key的设置
无论是react 和 vue,正确使用key,目的就是在一次循环中，找到与新节点对应的老节点，复用节点，节省开销。不设置肯定是不行的,但是设置为index（拼接为其他字段同理）肯定也是不行的，假设数组中被插入了一组数据那这个key值就是错误的了, 所以key一定要设置成唯一值。

## 5. 懒加载 Suspense 和 lazy
Suspense 和 lazy 可以实现 dynamic import 懒加载效果，原理和上述的路由懒加载差不多。在 React 中的使用方法是在 Suspense 组件中使用 `<LazyComponent>` 组件。
```jsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function demo () {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  )
}
```
## 5. 虚拟列表与时间分片
虚拟列表的简单实现
```jsx
let num  = 0
class Index extends React.Component<any, any>{
    state = {
        list: new Array(9999).fill(0).map(() =>{ 
            num++
            return num
        }),
        scorllBoxHeight: 500, /* 容器高度(初始化高度) */
        renderList: [],       /* 渲染列表 */
        itemHeight: 60,       /* 每一个列表高度 */
        bufferCount: 8,       /* 缓冲个数 上下四个 */
        renderCount: 0,       /* 渲染数量 */
        start: 0,             /* 起始索引 */
        end: 0                /* 终止索引 */
    }
    listBox: any = null
    scrollBox : any = null
    scrollContent:any = null
    componentDidMount() {
        const { itemHeight, bufferCount } = this.state
        /* 计算容器高度 */
        const scorllBoxHeight = this.listBox.offsetHeight
        const renderCount = Math.ceil(scorllBoxHeight / itemHeight) + bufferCount
        const end = renderCount + 1
        this.setState({
            scorllBoxHeight,
            end,
            renderCount,
        })
    }
    /* 处理滚动效果 */
    handerScroll=()=>{
        const { scrollTop } :any =  this.scrollBox
        const { itemHeight , renderCount } = this.state
        const currentOffset = scrollTop - (scrollTop % itemHeight)
        /* translate3d 开启css cpu 加速 */
        this.scrollContent.style.transform = `translate3d(0, ${currentOffset}px, 0)`
        const start = Math.floor(scrollTop / itemHeight)
        const end = Math.floor(scrollTop / itemHeight + renderCount + 1)
        this.setState({
            start,
            end,
       })
    }
     /* 性能优化：只有在列表start 和 end 改变的时候在渲染列表 */
    shouldComponentUpdate(_nextProps, _nextState){
        const { start , end } = _nextState
        return start !== this.state.start || end !==this.state.end 
    }
    /* 处理滚动效果 */
    render() {
        console.log(1111)
        const { list, scorllBoxHeight, itemHeight ,start ,end } = this.state
        const renderList = list.slice(start,end)
        return <div className="list_box"
            ref={(node) => this.listBox = node}
        >   
            <div  
               style={{ height: scorllBoxHeight, overflow: 'scroll', position: 'relative' }}  
               ref={ (node)=> this.scrollBox = node }
               onScroll={ this.handerScroll }   
            >
                { /* 占位作用 */}
                <div style={{ height: `${list.length * itemHeight}px`, position: 'absolute', left: 0, top: 0, right: 0 }} />
                { /* 显然区 */ }
                <div ref={(node) => this.scrollContent = node} style={{ position: 'relative', left: 0, top: 0, right: 0 }} >
                    {
                        renderList.map((item, index) => (
                            <div className="list" key={index} >
                                {item + '' } Item
                            </div>
                        ))
                    }
                </div>
            </div>

        </div>
    }
}

```

时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。使用`setTimeout` 和 `requestAnimationFrame`来分片加载数据可以缓解部分情况。

----
参考：https://juejin.cn/post/6908895801116721160


