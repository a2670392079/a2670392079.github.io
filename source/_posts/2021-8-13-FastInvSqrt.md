---
title: 2021-8-13-FastInvSqrt
date: 2021-08-13 10:33:39
tags: 算法
---
# 快速平方根倒数算法

快速平方根倒数算法也称为平方根倒数速算法(Fast Inverse Square Root)是用于快速计算 的一种算法。此算法由于出现在《雷神之锤III竞技场》源代码中而被人们所熟知。此算法最早被认为是由约翰·卡马克所发明，但后来的调查显示，该算法在这之前就于计算机图形学的硬件与软件领域有所应用，此算法至今为止仍未能确切知晓算法中所使用的特殊常数的起源。
下列代码是《雷神之锤III竞技场》源代码：

```c
float Q_rsqrt( float number )
{
	long i;
	float x2, y;
	const float threehalfs = 1.5F;
 
	x2 = number * 0.5F;
	y  = number;
	i  = * ( long * ) &y;                       // evil floating point bit level hacking
	i  = 0x5f3759df - ( i >> 1 );               // what the fuck?
	y  = * ( float * ) &i;
	y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration 
    // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
 
	return y;
}
```
## 1. 浮点数存储方式（IEEE754）
一个浮点数以32个二进制位表示一个有理数，而这32位由其意义分为三段：首先首位为符号位（si），如若是0则为正数，反之为负数；接下来的8位表示经过偏移处理（这是为了使之能表示-127－128, 偏移量B=127,E为指数值）后的指数；最后23位表示的则是有效数字中除最高位以外的其余数字(m)。公式表示：
$$
x=(-1)^{si}*(1+m)*2^{(E-B)}\\
$$
例如： 0-01111100-0100000000000000000000 $= (-1)^{0}*(1+0.250)*2^{(124-127)} = 0.15625$  

如果用浮点数序列表示整数，符号位占1位，数值占31位，则正整数为：$I = E * 2^{23} + M$,即$I = 124 * 2^{23} + 2^{21}$对于同样的32位二进制数码，若为浮点数表示时实际数值为$x=(1+m_x)2^{e_x}$，而若为整数表示时实际数值则为 $I_x=E_xL+M_x$，其中 $L=2^{n-1-b}$，这里n=32，b=8。式子中引入的新变量为：

等式1：
$$m_x=\frac{M_x}{L}\\$$
等式2：
$$e_x = E_x - B,其中B = 2^{b-1} - 1$$
## 2. 浮点数平方根倒数近似值
平方根倒数方程 
$$y=\frac{1}{\sqrt{x}}\\$$
取对数：
$$\log_2y = -\frac{1}{2}\log_2x\\$$
因为浮点数可表示为：$x=(1+m_x)*2^{e_x}$ 所以有$y=(1+m_y)*2^{e_y}$, 代入上式有：
$$
\log_2(1+m_y) + e_y = -\frac{1}{2}\log_2(1+m_x) - \frac{1}{2}e_x
$$
再度引入新数$\sigma$描述$\log_2{(1+x)}$与近似值R间的误差：由于$0 \le x < 1$ ，有$\log_2{(1+x)}\approx {x}$，则在此可定义$\sigma$与$x$的关系为$\log_2{(1+x)}\cong x+\sigma$，其中$\sigma$介于0到$\frac{1}{3}$，所以将$\log_2{(1+x)}= x+\sigma$代入上式得：
$$m_y+\sigma+e_y=-\frac{1}{2}m_x-\frac{1}{2}\sigma-\frac{1}{2}e_x$$
将之前等式1，等式2代入到上述方程中，有：
$$M_y+(E_y-B)L=-\frac{3}{2}\sigma{L}-\frac{1}{2}M_x-\frac{1}{2}(E_x-B)L$$
移项整理得：
$$E_yL+M_y=\frac{3}{2}(B-\sigma)L-\frac{1}{2}(E_xL+M_x)$$
又因为浮点规格存储的正浮点数x，若将其作为长整型表示，则示值为：$I_x=E_xL+M_x$，所以x的平方根倒数的首次近似值的整数表示值为：
$$I_y=E_yL+M_y=R-\frac{1}{2}(E_xL+M_x)=R-\frac{1}{2}I_x，\\其中R=\frac{3}{2}(B-\sigma)L，B=2^{b-1}-1 L=2^{n-1-b}，n=32，b=8。$$
这个式子对应着源代码中的这一行：``i  = 0x5f3759df - ( i >> 1 );``，然后将整数表示值换回表示浮点数：``y  = * ( float * ) &i;``。这样就得到了浮点数的平方根倒数的近似值。   
由第三部分可知：0x5f3759df 对应着R，即3/2(B-$\sigma$)L.当R为0x5f3759df时值最精准。

"现在不仅该算法的原作者不明，人们也仍无法明确当初选择这个“魔术数字”的方法。Chris Lomont在研究中曾做了个试验：他编写了一个函数，以在一个范围内遍历选取R值的方式将逼近误差降到最小，以此方法他计算出了线性近似的最优R值0x5f37642f（与代码中使用的0x5f3759df相当接近），但以之代入算法计算并进行一次牛顿迭代后，所得近似值与代入0x5f3759df的结果相比精度却仍略微更低。……在Charles McEniry的论文中，他使用了一种类似Lomont但更复杂的方法来优化R值：他最开始使用穷举搜索，所得结果与Lomont相同；而后他尝试用带权二分法寻找最优值，所得结果恰是代码中所使用的魔术数字0x5f3759df"——维基百科

最后使用牛顿迭代法使答案逼近
牛顿迭代法：设方程 y = f(x) - 0;已知y求x,先取得x的一个近似值$x_0$,设k为$x_0$处切线斜率：
$$
y_1 - y_0 = k(x_1-x_0)\\
0-y_0 = k(x_1-x_0)\\
x_1 = x_0-\frac{y_0}{k}\\
x_1= x_0 \frac{f(x_0)}{f^{'}{x_0}}
$$
反复重复以上步骤获得更精确的值：
$$x_{n+1} = x_n-\frac{f(x_n)}{f^{'}{x_n}}$$


# tmd我怎么就写不出来！



