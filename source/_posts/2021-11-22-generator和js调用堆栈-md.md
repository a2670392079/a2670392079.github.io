---
title: '2021-11-22-generator和js调用堆栈.md'
date: 2021-11-22 15:37:52
tags:
---
## generator的es5实现
在[regenerator-runtime](https://github.com/facebook/regenerator)中有对generator的详细es5实现,我们实现一个最简单的 generator如下：
```js
/**
 * @param cb cb为编译后的generator函数
 */
function generator(cb) {
  return (function () {
    var obj = {
      next: 0,
      stop: function () {},
    };
    return {
      next: function () {
        var res = cb(obj);
        return {
          value: undefined,
          done: res === undefined,
        };
      },
    };
  })();
}

// 测试函数
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}

// es5版的generator函数
function _test() {
  var a;
  // 编译后
  function $cb(_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成几块
        // 每次执行 next 函数就执行一块代码
        // 并且表明下次需要执行哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
        // 执行完毕
        case 6:
        case "end":
          return _context.stop();
      }
    }
  }
  return generator($cb);
}
const t = _test()
t.next()
// {value: undefined, done: false}
t.next()
// {value: undefined, done: false}
t.next()
// {value: undefined, done: true}
```
## 在上面拼夕夕的generator函数基础上我们来看看js调用堆栈
### 首先先了解什么是执行上下文
执行上下文就是当前JavaScript代码被解析和执行是所在环境的抽象概念，JavaScript中运行任何的代码都是在执行上下文中运行。
### 执行上下文的类型，总共有三类

> + 全局执行上下文：这是默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。共有两个过程：1.创建有全局对象，在浏览器中这个全局对象就是window对象。2.将this指针指向这个全局对象。一个程序中只能存在一个执行上下文。
> + 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在多个函数执行上下文，这些函数执行上下文按照特定的顺序执行一系列步骤，后文具体讨论。
> + Eval函数执行上下文：运行在eval函数中的代码也获得了自己的执行上下文，但由于Eval较为少用到，也不建议使用，就不去详细讨论了。。。（eval方法是在运行时对脚本进行解释执行，而普通的javascript会有一个预处理的过程。所以会有一些性能上的损失；eval也存在一个安全问题，因为它可以执行传给它的任何字符串，所以永远不要传入字符串或者来历不明和不受信任源的参数。
### 执行栈
执行栈，也叫调用栈，用于存储在代码执行期间创建的所有执行上下文。

当JavaScript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。每当发生函数调用时，引擎都会为该函数创建一个新的执行上下文并Push到当前执行栈的栈顶。

引擎会运行执行上下文在执行栈栈顶的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中Pop出，上下文控制权将转到当前执行栈的下一个执行上下文。

先上一段js代码：
```js
var a = 1;
funtion b(){console.log(a)};
b();
```
在这个过程中全局执行上下文入栈->a执行上下文入栈->a执行上下文出栈最后只剩下了全局执行上下文，回到generator那边最后明明是在全局上下文里执行的``t.next()``为啥还是正确的结果呢？这就和执行上下文创建以及闭包和js堆栈相关了。先来看看执行上下文的创建。执行上下文分两个阶段创建：1.创建阶段； 2.执行阶段

### 创建阶段

在任意的JavaScript代码被执行前，执行上下文处于创建阶段。在创建阶段总共发生了三件事情：

> 1. 确定this的值，也被称为This Binding(this的值大家伙都整挺明白的略过)；
> 2. LexicaEnvironment（词法环境）组件被创建；
> 3. VariableEnvironment（变量环境）组件被创建。
#### 词法环境（Lexical Environment):
官方ES6文档将词法环境定义为：

词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符与特定变量和函数的关联关系。词法环境由环境记录（environment record）和可能为空引用（null）的外部词法环境组成。
简而言之，词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）

在词法环境中，有两个组成部分：

> 1. 环境记录（environment record）: 环境记录是存储变量和函数声明的实际位置
> 2. 对外部环境的引用: 对外部环境的引用意味着它可以访问其外部词法环境

词法环境有两种类型：

> 1. 全局环境（在全局执行上下文中）是一个没有外部环境词法环境的词法环境。全局环境的外部环境引用为null。它拥有一个全局对象（window对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this的值指向这个全局对象。
> 2. 函数环境，用户在函数中定义的变量被存储在环境记录中，包含了arguments对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。
注意：对于函数环境而言，环境记录还包含了一个arguments对象，该对象包含了索引和传递给函数的参数之间的映射以及传递给函数的参数的长度（数量）。


环境记录同样也有两种类型：

> 1. 声明性环境记录存储变量，函数和参数。一个函数环境包含声明性环境记录。
> 2. 对象环境记录用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。

#### 变量环境：

变量环境是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，词法环境（LexicalEnvironment 组件）和 变量环境（VariableEnvironment 组件）的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。

当然一个generator并不需要说这些，但是多看一点总是好的。

### 执行阶段
这里就长话短说了， 此阶段，完成对所有变量的分配，最后执行代码。
回到最开始generator的代码，在``_test``函数执行的过程中创建了属于它的执行上下文，执行上下文中的变量环境中存储了``a``,事实上它是被存储在堆内存中，这也是闭包的原理，我们执行``t.next()``的时候是访问了全局上下文中的``t``，虽然``_test``的执行上下文以及出栈了但是我们仍然能从堆中访问到``a``,每次执行``t.next()``都有一次它执行上下文的出栈和入栈，这也是generator执行权交换的过程，在它的执行上下文出栈后执行权就交还给了栈顶的执行上下文，看起来就像是只原本``test``函数中的部分代码块。


## 总结
事实上es5实现generator主要的功劳还得靠babel编译generator函数给它转换为一个状态机，闭包、作用域之类的其实是耳熟能详的知识，但是用generator的时候没有去思考过它怎么实现的，以后遇到一些常用却不了解原理的还得自己去猜一猜然后再去验证这样能加深理解。

